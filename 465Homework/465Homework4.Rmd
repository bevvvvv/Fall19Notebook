---
title: "Data Structures and Algorithms Homework 4"
subtitle: "Due Wednesday Sept 25; Joseph Sepich (jps6444)"
output:
  pdf_document:
    toc: false
    toc_depth: 2
    number_sections: true
    keep_tex: false
---

# Problem 1 Pre and Post Processing

## Part 1a

DFS works by going depth first as the name states. This means that in order to explor a connected node you are finding it in a recursive stack. If a node U was a child of a node V, then the only way for that to happen would be for the DFS algorithm to call explore on U from the explore function of V. You can see that in a stack the existence of the property that post(u) < post(v) implies v is an ancestor of u can be shown inductively. First of all U and V are already determined to have an edge between them, so they must be on the same tree. If they didn't have an edge then it would be possible that u and v are just not connected and you explored one first. Our base case would be U is the direct child of V. As stated before this means U would have been called from the explore V function if post(u) = post(v) - 1. If we assume then going off this base case that post(u) = post(v) - k implies U is a descendant of V, then we can see that post(u) = post(v) - (k+1). This value is also post(v) - (k + 1) = post(v) - k -1 and we said in our base case this means that post(v) - k - 1 is a child of post(v) - k, so u must always be a descendant of v if post(u) < post(v).

\pagebreak

## Part 1b

\pagebreak

# Problem 2 Funny Money

To find a combination to obtain a 10$ bill, we can create a DFS tree. Since there are only two options, connected to each node, it the tree is a binary tree. Leaves occur when both choice nodes already appeared as an ancestor to that node. We want a node that gives us [10, 11], since that means we currently can get a 10 dollar bill. An example of the tree can be found below.

![](./FunnyMoneyDFS.png){ height=50%, width=50%}

According to this DFS tree I made of the possible options, there is no way to obtain a $10 bill through the printing machine starting with a 1 dollar bill.

\pagebreak

# Problem 3 Topological Ordering

## Part 3a

* A - [1, 14]
* B - [15, 16]
* C - [2, 13]
* D - [3, 10]
* E - [11, 12]
* F - [4, 9]
* G - [5, 6]
* H - [7, 8]

\pagebreak

## Part 3b

The sources of the DAG are A and B. The sinks of the DAG are G and H.

\pagebreak

## Part 3c

1. B
2. A
3. C
4. E
5. D
6. F
7. H
8. G

\pagebreak

## Part 3d

In the ordering of this DAG, it is always possible to swap two consecutive nodes that are not connected by edge. An example of this would be A and B, D and E, or G and H. This means that there are 8 possible ways to order the topological sort or 2^3.

\pagebreak

# Problem 4 One-Way Streets

## Part 4a

The roads in the city of Computopia are in the form of a directed graph with the intersections as nodes and roads as edges. The mayor has claimed that any intersection can be reached by starting at any other intersection. This implies that the entire city is one strongly connected component where any U and V have a path from U to V and V to U. We can use our algorithm for finding a strongly connected sink component. To do this we reverse all the edges and run DFS. The vertex with the highest post number is in a source strongly connected component on the reversed graph, but in a sink strongly connected component on the regular graph. If we run DFS from this point and obtain every node in the graph, then we know that the graph has to be a singly strongly connected component, and the mayor's claim holds. Since this algorithm just requires a run of DFS twice to determine the truth value of the original statement, the running time must be 2*O(|v| + |E|) = O(|V| + |E|), which is linear time.

\pagebreak

## Part 4b

The mayor's new claim revolves around the town-hall. She says that if you start at the node that is the town-hall, then no matter when you go you can always end at the town hall. This implies that the town-hall is contained in the sink strongly connected component of the graph of roads and intersections. To determine this you can run DFS on the reverse graph and start at the town-hall. If the town-hall has the largest post-number, then it must be in a source strongly connected component of the reversed graph; however there could be multiple source components, but this is okay. In order to figure out if the town-hall is in a source component. Then if the town-hall pre and post numbers are not contained within any previously found source component intervals, then it cannot be a child, so you can remove the source component you found and run the algorithm again. If the town-hall is never in the source component, then the mayor is wrong, however if the town-hall is in a source component, on this reverse graph, then it must be in a sink strongly connected component on the non-reversed graph and would evalute to true.

This algorithm for the more specific claim, would have the same growth rate as the previous (linear), but would have a greater coefficient, because it would invovle running DFS more times in the worst case scenario, since there is more to validate.

\pagebreak

# Problem 5 City Hopping

## Part 5a

Is there a feasible rouute from s to t?

You can easily model a DFS algorithm to understand if s to t is a plausible route. Run a standard DFS algortihm, but do not add the next city node as a child, unless the length value of the edge is less than or equal to your max range. Then you can check to seed if the pre and post number of s encompasses the pre and post number of t. 

```{}
clock = 1

# G is a graph
# L is max range
# s is source city
# t is target city
findRoute(G, L, s, t) {
  visited = new boolean[|V|] # array for storing pre and post numbers
  pre = new int[|V|]
  post = new int[|V|]
  pre[s] = clock
  clock++
  foreach {s, v} that is an edge {
    if (lengths[{s, v}] <= L && !visited[v]) { ## CHECK FOR MILEAGE
      Explore(G, v, visited)
    }
  }
  post[s] = clock
  
  if (pre[s] < pre[t] && post[s] > post[t]) { ## CHECK FOR CHILD
    return true
  }
  return false
}

Explore(G, s, visited) {
  visited[s] = true
  pre[s] = clock
  clock++
  foreach {s, v} that is an edge{
    if (lengths[{s, v}] <= L && !visited[v]) { ## CHECK FOR MILEAGE
      Explore(G, v, visited)
    }
  post[s] = clock
  clock++
  }
}

```

Since this algorithm is merely DFS with a different coefficient, since it has a different number of steps in each function, it is by definition O(|V| + |E|). The worst case is all vertices are visited and each edge is traversed,

\pagebreak

## Part 5b

Once you know that a path exists and you are looking for the minimum fuel tank, you are now looking at all the possible paths from s to t, because each path would require different mileage. For this you would have to find the maximum value of l_e_ for each path that is available from s to t.













