---
title: "Data Structures and Algorithms Homework 9"
subtitle: "Due Wednesday Oct 30; Joseph Sepich (jps6444)"
output:
  pdf_document:
    toc: false
    toc_depth: 2
    number_sections: true
    keep_tex: false
---

# Problem 1

Collaborators:

\pagebreak

# Problem 2

## Part 1

\pagebreak

## Part 2

\pagebreak

## Part 3

\pagebreak

## Part 4

\pagebreak

# Problem 3 Kruskal's Algorithm

Algorithm by iteration:

1. FD (Cut (S = {F}, V - S))
2. AB (Cut (S = {F, D, A}, V - S))
3. BE (Cut (S = {F, D, A, B}, V - S))
4. DE (Cut (S = {F, D}, V - S))
5. CE (Cut (S = {A, B, D, E, F}, {C}))

Final MST:

```{r, out.width = "400px", echo=FALSE}
knitr::include_graphics("./Kruskal.PNG")
```

\pagebreak

# Problem 4 Prim's Algorithm

```{r, out.width = "400px", echo=FALSE}
knitr::include_graphics("./Prims.PNG")
```

\pagebreak

# Problem 5

To compute a maximum spanning tree what we could do is take a minimum spanning tree algorithm such as Kruskal's Algorithm and run it on the graph with all edge weights multiplied by negative one. This would reverse any comparisons of edge weights that are made, so for example if you have two edges of weight 1 and 5, then in the standard minimum spanning tree you would choose the 1 weighted edge first, but when multiplied by negative 1, you get -1, and -5, which compels the minimum algorithm to select the -5 weight. The steps for the algoritm would be as follows:

1. Multiply each edge weight by -1, which would run in O(|E|) time.
2. Run Kruskal's on the graph using negative edge weights, which takes O(|E|log|V|).
3. THe output is the output of Kruskal's but you must multiply the edge weights by negative one again.


You could also ignore this method and just modify Kruskal's algorithm:

```{}
def Kruskal_Max(G, w) {
  A = empty set
  for all v in V {
    make_set(v)
  }
  G.E = G.E sorted in decreasing order by w
  for all (u, v) in G.E {
    if find_set(u) != find_set(v) {
      A = A union {(u,v)}
      union(u,v)
    }
  }
  return A
}
```

You know this algorithm must be correct, because you merely reverse the comparison operator from being small to large.



































